{"kind":"article","primaryContentSections":[{"content":[{"level":2,"text":"Caching","type":"heading","anchor":"Caching"},{"inlineContent":[{"type":"text","text":"Images can take a lot of space. By using Nuke, you can ensure that when you download an image, it will be cached so that you don’t have to download it again. Nuke provides three different caching layers."}],"type":"paragraph"},{"level":3,"text":"L1. Memory Cache (Default)","type":"heading","anchor":"L1-Memory-Cache-Default"},{"inlineContent":[{"type":"text","text":"The images are stored in a fast in-memory cache: "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageCache","type":"reference","isActive":true},{"type":"text","text":". It uses "},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Cache_algorithms#Examples","type":"reference","isActive":true},{"type":"text","text":" replacement algorithm and has a strict size limit. It also automatically evicts images on memory warnings and removes a portion of its contents when the application enters background mode."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Nuke stores decompressed (bitmapped) images in the memory cache. If your app is loading and displaying high-resolution images, consider downsampling them and\/or increasing cache limits. For context, a bitmap for a 6000x4000px image takes 92 MB (assuming it needs 4 bytes per pixel)."}]}],"name":"Important","type":"aside","style":"important"},{"level":3,"text":"L2. HTTP Disk Cache (Default)","type":"heading","anchor":"L2-HTTP-Disk-Cache-Default"},{"inlineContent":[{"type":"text","text":"By default, unprocessed image data is stored in native "},{"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/urlcache","type":"reference","isActive":true},{"type":"text","text":", which is part of the "},{"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/url_loading_system","type":"reference","isActive":true},{"type":"text","text":". The main feature of "},{"type":"codeVoice","code":"URLCache"},{"type":"text","text":" is its support of "},{"identifier":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Headers\/Cache-Control","type":"reference","isActive":true},{"type":"text","text":". Here is an example of an HTTP header with cache control."}],"type":"paragraph"},{"code":["HTTP\/1.1 200 OK","Cache-Control: public, max-age=3600","Expires: Mon, 26 Jan 2016 17:45:57 GMT","Last-Modified: Mon, 12 Jan 2016 17:45:57 GMT","ETag: \"686897696a7c876b7e\""],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This response is cacheable, and will be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"fresh"}]},{"type":"text","text":" for 1 hour. When the response becomes "},{"type":"emphasis","inlineContent":[{"type":"text","text":"stale"}]},{"type":"text","text":", the client "},{"type":"emphasis","inlineContent":[{"type":"text","text":"validates"}]},{"type":"text","text":" it by making a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conditional"}]},{"type":"text","text":" request using the "},{"type":"codeVoice","code":"If-Modified-Since"},{"type":"text","text":" and\/or "},{"type":"codeVoice","code":"If-None-Match"},{"type":"text","text":" headers. If the response is still fresh, the server returns status code "},{"type":"codeVoice","code":"304 Not Modified"},{"type":"text","text":" to instruct the client to use cached data, or it would return "},{"type":"codeVoice","code":"200 OK"},{"type":"text","text":" with new data otherwise."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Make sure that the images served by the server have "},{"isActive":true,"type":"reference","overridingTitle":"Cache Control","overridingTitleInlineContent":[{"type":"text","text":"Cache Control"}],"identifier":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Headers\/Cache-Control"},{"type":"text","text":" set correctly."}]}],"name":"Tip","type":"aside","style":"tip"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, "},{"type":"codeVoice","code":"URLCache"},{"type":"text","text":" doesn’t serve stale images offline. To show a stale image, pass the "},{"type":"codeVoice","code":"URLRequest"},{"type":"text","text":" with cache policy set to "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/nsurlrequest\/cachepolicy\/returncachedatadontload"},{"type":"text","text":" and then perform a second request to refresh the image."}]}],"name":"Important","type":"aside","style":"important"},{"level":3,"text":"L3. Aggressive Disk Cache (Optional)","type":"heading","anchor":"L3-Aggressive-Disk-Cache-Optional"},{"inlineContent":[{"type":"text","text":"If your server uses unique URLs for images for which the contents never change, consider enabling "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/DataCache","type":"reference","isActive":true},{"type":"text","text":" (see "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/Configuration-swift.struct\/withDataCache","type":"reference","isActive":true},{"type":"text","text":" that also takes care of disabling the default "},{"type":"codeVoice","code":"URLCache"},{"type":"text","text":"). It’s a fast persistent cache with non-blocking writes that allows reads to be parallel to writes and each other. It also works offline and reduces pressure on "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"By default "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/DataCache"},{"type":"text","text":", stores only the original image data. To store processed images, use one of the data cache policies that enable it, for example "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/DataCachePolicy\/automatic"},{"type":"text","text":"."}]}],"name":"Tip","type":"aside","style":"tip"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To save disk space, see "},{"type":"codeVoice","code":"ImageEncoders.ImageIO"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ImageEncoder.isHEIFPreferred"},{"type":"text","text":" option for HEIF support."}]}],"name":"Tip","type":"aside","style":"tip"},{"level":2,"text":"Prefetching","type":"heading","anchor":"Prefetching"},{"inlineContent":[{"type":"text","text":"Prefetching means downloading data ahead of time in anticipation of its use. It creates an illusion that the images are simply available the moment you want to see them – no networking involved. It’s very effective. See "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/prefetching","type":"reference","isActive":true},{"type":"text","text":" to learn more about how to enable it."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you apply processors when displaying final images, make sure to use the same processors for prefetching. Otherwise, Nuke will end up populating the memory cache with the versions of the images you are never going to need for display."}]}],"name":"Important","type":"aside","style":"important"},{"level":2,"text":"Decompression","type":"heading","anchor":"Decompression"},{"inlineContent":[{"type":"text","text":"Image formats often use compression to reduce the overall data size, but it comes at a cost. An image needs to be decompressed, or "},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitmapped"}]},{"type":"text","text":", before it can be displayed. "},{"type":"codeVoice","code":"UIImage"},{"type":"text","text":" does "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" eagerly decompress this data until you display it. It leads to performance issues like scroll view stuttering. To avoid it, Nuke automatically decompresses the images in the background. Decompression only runs if needed; it won’t run for already processed images."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/219"},{"type":"text","text":" to learn more about image decoding and downsampling."}]}],"name":"Note","type":"aside","style":"note"},{"level":2,"text":"Downsample Images","type":"heading","anchor":"Downsample-Images"},{"inlineContent":[{"type":"text","text":"Ideally, the app should download the images optimized for the target device screen size, but it’s not always possible. To reduce memory usage, downsample the images."}],"type":"paragraph"},{"code":["\/\/ Target size is in points","let request = ImageRequest(url: url,  processors: [.resize(width: 320)])"],"syntax":"swift","type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Some image formats, such as jpeg, can have thumbnails embedded in the original image data. If you are working with a large image and want to show only a thumbnail, consider using "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageRequest\/ThumbnailOptions"},{"type":"text","text":". If the thumbnails aren’t available, they are generated. It can be up to 4x faster than using "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageProcessors\/Resize"},{"type":"text","text":" for high-resolution images."}]}],"name":"Tip","type":"aside","style":"tip"},{"level":2,"text":"Main Thread Performance","type":"heading","anchor":"Main-Thread-Performance"},{"inlineContent":[{"type":"text","text":"Nuke has a range of optimizations across the board to ensure it does as little work on the main thread as possible."}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"CoW"}]},{"type":"text","text":". The primary type in Nuke is "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageRequest"},{"type":"text","text":". It has multiple options, so the struct is quite large. To make sure that passing it around is as efficient as possible, "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageRequest"},{"type":"text","text":"  uses a Copy-on-Write technique."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"OptionSet"}]},{"type":"text","text":". In one of the recent versions of Nuke, "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageRequest"},{"type":"text","text":" was optimized even further by using option sets and reordering properties to take advantage of gaps in memory stride. It currently takes only 48 bytes in memory (compared to 176 bytes in the previous versions)."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"ImageRequest.CacheKey"}]},{"type":"text","text":". Most frameworks use strings to uniquely identify requests. But string manipulations are expensive, and this is why in Nuke, there is a special internal type, "},{"type":"codeVoice","code":"ImageRequest.CacheKey"},{"type":"text","text":", which allows for efficient equality checks with no strings manipulation."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"These are just some examples of the optimization techniques used in Nuke. There are many more. Every new feature in Nuke is designed with performance in mind to make sure there are no performance regressions ever."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"One thing you can do to optimize the main thread’s performance is create URLs in the background, as their initialization can be relatively expensive. It’s best to do it during decoding."}]}],"name":"Tip","type":"aside","style":"tip"},{"level":2,"text":"Resumable Downloads","type":"heading","anchor":"Resumable-Downloads"},{"inlineContent":[{"type":"text","text":"Make sure your server supports resumable downloads. If the data task is terminated when the image is partially loaded (either because of a failure or a cancellation), the next load will resume where the previous one left off. Resumable downloads require the server to support "},{"identifier":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Range_requests","type":"reference","isActive":true},{"type":"text","text":". Nuke supports both validators: "},{"type":"codeVoice","code":"ETag"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Last-Modified"},{"type":"text","text":". Resumable downloads are enabled by default. You can learn more in "},{"identifier":"https:\/\/kean.blog\/post\/resumable-downloads","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"level":2,"text":"Coalescing","type":"heading","anchor":"Coalescing"},{"inlineContent":[{"type":"text","text":"Thanks to coalescing (enabled by default), the pipeline avoids doing any duplicated work when loading images. Let’s take the following two requests as an example."}],"type":"paragraph"},{"code":["let url = URL(string: \"http:\/\/example.com\/image\")","pipeline.loadImage(with: ImageRequest(url: url, processors: [","    .resize(size: CGSize(width: 44, height: 44)),","    .gaussianBlur(radius: 8)","]))","pipeline.loadImage(with: ImageRequest(url: url, processors: [","    .resize(size: CGSize(width: 44, height: 44))","]))"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Nuke will load the data only once, resize the image once and blur it also only once. There is no duplicated work done. When you request an image, the pipeline creates a dependency graph of tasks needed to deliver the final images and reuses the ones that it can."}],"type":"paragraph"},{"level":2,"text":"Progressive Decoding","type":"heading","anchor":"Progressive-Decoding"},{"inlineContent":[{"type":"text","text":"Nuke supports progressive JPEG out of the box. You’ll first see a blurry version of the full image, which gets sharper as the image is decoded or rendered in the app."}],"type":"paragraph"},{"level":2,"text":"Request Priorities","type":"heading","anchor":"Request-Priorities"},{"inlineContent":[{"type":"text","text":"Nuke is fully asynchronous and performs well under stress. "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline","type":"reference","isActive":true},{"type":"text","text":" distributes its work on "},{"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/operationqueue","type":"reference","isActive":true},{"type":"text","text":" dedicated to a specific type of work, such as processing and decoding. Each queue limits the number of concurrent tasks, respects the request priorities, and cancels the work as soon as possible."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Nuke allows you to set the request priority and update it for outstanding tasks. It uses priorities for prefetching: the requests created by the prefetcher all have "},{"type":"codeVoice","code":".low"},{"type":"text","text":" priority to make sure they don’t interfere with the “regular” requests. See "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/prefetching","type":"reference","isActive":true},{"type":"text","text":" to learn more."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"There are many other creative ways to use priorities. For example, when the user taps an image in a grid to open it full screen, you can lower the priority of the requests for the images that are not visible on the screen."}],"type":"paragraph"},{"code":["final class ImageView: UIView {","    private var task: ImageTask?","","    override func willMove(toWindow newWindow: UIWindow?) {","        super.willMove(toWindow: newWindow)","","        task?.priority = newWindow == nil ? .low : .high","    }","}"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Rate Limiting","type":"heading","anchor":"Rate-Limiting"},{"inlineContent":[{"type":"text","text":"If the app starts and cancels requests at a fast rate, Nuke will rate limit the requests, protecting "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":". "},{"type":"codeVoice","code":"RateLimiter"},{"type":"text","text":" uses a classic "},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Token_bucket","type":"reference","isActive":true},{"type":"text","text":" algorithm. The implementation supports quick bursts of requests which can be executed without any delays when “the bucket is full”. It is important to make sure "},{"type":"codeVoice","code":"RateLimiter"},{"type":"text","text":" only kicks in when needed, but when the user opens the screen, all the requests are fired immediately."}],"type":"paragraph"},{"level":2,"text":"Auto Retry","type":"heading","anchor":"Auto-Retry"},{"inlineContent":[{"type":"text","text":"Enable "},{"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/urlsessionconfiguration\/2908812-waitsforconnectivity","type":"reference","isActive":true},{"type":"text","text":" on "},{"type":"codeVoice","code":"URLSession"},{"type":"text","text":" to indicate that the session should wait for connectivity to become available instead of failing the request immediately in case of a network failure."}],"type":"paragraph"},{"level":2,"text":"Measure","type":"heading","anchor":"Measure"},{"inlineContent":[{"type":"text","text":"If you want to see how the system behaves, how long each operation takes, and how many are performed in parallel, enable the "},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/Configuration-swift.struct\/isSignpostLoggingEnabled","type":"reference","isActive":true},{"type":"text","text":" option and use the "},{"type":"codeVoice","code":"os_signpost"},{"type":"text","text":" Instrument. For more information, see "},{"identifier":"https:\/\/developer.apple.com\/documentation\/os\/logging","type":"reference","isActive":true},{"type":"text","text":" and "},{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/405\/","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"level":2,"text":"Selecting a System","type":"heading","anchor":"Selecting-a-System"},{"inlineContent":[{"type":"text","text":"Make sure you select one image loading framework and stick to it. If you use more than one framework, it will prevent them from managing the system resources efficiently, such as caches. If, for any reason, you must use more than one framework, ensure that they at least share the same memory and disk caches."}],"type":"paragraph"}],"kind":"content"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"seeAlsoSections":[{"identifiers":["doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/prefetching","doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/combine","doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/caching","doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePrefetcher"],"generated":true,"anchor":"Performance","title":"Performance"}],"sections":[],"abstract":[{"text":"Learn about the performance features in Nuke and how to make the most of them.","type":"text"}],"variants":[{"paths":["\/documentation\/nuke\/performance-guide"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/com.github.kean.nuke\/documentation\/Nuke"]]},"metadata":{"roleHeading":"Article","role":"article","title":"Performance Guide","modules":[{"name":"Nuke"}]},"identifier":{"url":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/performance-guide","interfaceLanguage":"swift"},"references":{"https://developer.apple.com/documentation/foundation/nsurlrequest/cachepolicy/returncachedatadontload":{"titleInlineContent":[{"text":".returnCacheDataDontLoad","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/nsurlrequest\/cachepolicy\/returncachedatadontload","url":"https:\/\/developer.apple.com\/documentation\/foundation\/nsurlrequest\/cachepolicy\/returncachedatadontload","type":"link","title":".returnCacheDataDontLoad"},"https://developer.apple.com/videos/play/wwdc2018/219":{"titleInlineContent":[{"text":"Image and Graphics Best Practices","type":"text"}],"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/219","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/219","type":"link","title":"Image and Graphics Best Practices"},"doc://com.github.kean.nuke/documentation/Nuke/ImageRequest/ThumbnailOptions":{"navigatorTitle":[{"kind":"identifier","text":"ThumbnailOptions"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ThumbnailOptions"}],"url":"\/documentation\/nuke\/imagerequest\/thumbnailoptions","abstract":[{"text":"Thumbnail options.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageRequest\/ThumbnailOptions","kind":"symbol","title":"ImageRequest.ThumbnailOptions","role":"symbol"},"doc://com.github.kean.nuke/documentation/Nuke/combine":{"title":"Combine","url":"\/documentation\/nuke\/combine","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/combine","abstract":[{"type":"text","text":"Learn how to use Combine publishers to improve image loading performance in your apps."}],"role":"article","kind":"article","type":"topic"},"doc://com.github.kean.nuke/documentation/Nuke/ImagePipeline/Configuration-swift.struct/isSignpostLoggingEnabled":{"kind":"symbol","title":"isSignpostLoggingEnabled","type":"topic","role":"symbol","url":"\/documentation\/nuke\/imagepipeline\/configuration-swift.struct\/issignpostloggingenabled","abstract":[{"code":"false","type":"codeVoice"},{"text":" by default. If ","type":"text"},{"code":"true","type":"codeVoice"},{"text":", enables ","type":"text"},{"code":"os_signpost","type":"codeVoice"},{"text":" logging for","type":"text"},{"text":" ","type":"text"},{"text":"measuring performance. You can visually see all the performance","type":"text"},{"text":" ","type":"text"},{"text":"metrics in ","type":"text"},{"code":"os_signpost","type":"codeVoice"},{"text":" Instrument. For more information see","type":"text"},{"text":" ","type":"text"},{"text":"https:\/\/developer.apple.com\/documentation\/os\/logging and","type":"text"},{"text":" ","type":"text"},{"text":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/405\/.","type":"text"}],"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"isSignpostLoggingEnabled","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Bool","preciseIdentifier":"s:Sb","kind":"typeIdentifier"}],"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/Configuration-swift.struct\/isSignpostLoggingEnabled"},"https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests":{"titleInlineContent":[{"text":"HTTP Range Requests","type":"text"}],"identifier":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Range_requests","url":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Range_requests","type":"link","title":"HTTP Range Requests"},"https://developer.apple.com/documentation/os/logging":{"titleInlineContent":[{"text":"Apple Documentation: Logging","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/os\/logging","url":"https:\/\/developer.apple.com\/documentation\/os\/logging","type":"link","title":"Apple Documentation: Logging"},"doc://com.github.kean.nuke/documentation/Nuke/DataCache":{"navigatorTitle":[{"text":"DataCache","kind":"identifier"}],"url":"\/documentation\/nuke\/datacache","title":"DataCache","type":"topic","abstract":[{"text":"An LRU disk cache that stores data in separate files.","type":"text"}],"role":"symbol","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/DataCache","kind":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DataCache","kind":"identifier"}]},"doc://com.github.kean.nuke/documentation/Nuke/prefetching":{"title":"Prefetching","abstract":[{"text":"Learn how to prefetch images to improve user experience.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/nuke\/prefetching","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/prefetching"},"doc://com.github.kean.nuke/documentation/Nuke/ImagePipeline":{"title":"ImagePipeline","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline","kind":"symbol","url":"\/documentation\/nuke\/imagepipeline","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"ImagePipeline"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImagePipeline"}],"abstract":[{"type":"text","text":"The pipeline downloads and caches images, and prepares them for display."}]},"https://developer.apple.com/documentation/foundation/urlsessionconfiguration/2908812-waitsforconnectivity":{"titleInlineContent":[{"code":"waitsForConnectivity","type":"codeVoice"}],"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/urlsessionconfiguration\/2908812-waitsforconnectivity","url":"https:\/\/developer.apple.com\/documentation\/foundation\/urlsessionconfiguration\/2908812-waitsforconnectivity","type":"link","title":"waitsForConnectivity"},"doc://com.github.kean.nuke/documentation/Nuke/ImagePipeline/DataCachePolicy/automatic":{"title":"ImagePipeline.DataCachePolicy.automatic","fragments":[{"text":"case","kind":"keyword"},{"text":" ","kind":"text"},{"text":"automatic","kind":"identifier"}],"abstract":[{"text":"Store original image data for requests with no processors. Store","type":"text"},{"text":" ","type":"text"},{"inlineContent":[{"text":"only","type":"text"}],"type":"emphasis"},{"text":" processed images for requests with processors.","type":"text"}],"kind":"symbol","role":"symbol","url":"\/documentation\/nuke\/imagepipeline\/datacachepolicy\/automatic","type":"topic","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/DataCachePolicy\/automatic"},"https://en.wikipedia.org/wiki/Token_bucket":{"titleInlineContent":[{"text":"token bucket","type":"text"}],"identifier":"https:\/\/en.wikipedia.org\/wiki\/Token_bucket","url":"https:\/\/en.wikipedia.org\/wiki\/Token_bucket","type":"link","title":"token bucket"},"doc://com.github.kean.nuke/documentation/Nuke/ImageRequest":{"title":"ImageRequest","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageRequest","kind":"symbol","url":"\/documentation\/nuke\/imagerequest","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"ImageRequest"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImageRequest"}],"abstract":[{"type":"text","text":"Represents an image request that specifies what images to download, how to"},{"type":"text","text":" "},{"type":"text","text":"process them, set the request priority, and more."}]},"https://kean.blog/post/resumable-downloads":{"titleInlineContent":[{"text":"“Resumable Downloads”","type":"text"}],"identifier":"https:\/\/kean.blog\/post\/resumable-downloads","url":"https:\/\/kean.blog\/post\/resumable-downloads","type":"link","title":"“Resumable Downloads”"},"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control":{"titleInlineContent":[{"text":"Cache Control","type":"text"}],"identifier":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Headers\/Cache-Control","url":"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Headers\/Cache-Control","type":"link","title":"Cache Control"},"doc://com.github.kean.nuke/documentation/Nuke/ImagePipeline/Configuration-swift.struct/withDataCache":{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePipeline\/Configuration-swift.struct\/withDataCache","title":"withDataCache","type":"topic","role":"symbol","url":"\/documentation\/nuke\/imagepipeline\/configuration-swift.struct\/withdatacache","abstract":[{"text":"A configuration with an aggressive disk cache (","type":"text"},{"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/DataCache","isActive":true,"type":"reference"},{"text":") with a","type":"text"},{"text":" ","type":"text"},{"text":"size limit of 150 MB. An HTTP cache (","type":"text"},{"type":"codeVoice","code":"URLCache"},{"text":") is disabled.","type":"text"}],"fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"withDataCache"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Configuration","preciseIdentifier":"s:4Nuke13ImagePipelineC13ConfigurationV"}],"kind":"symbol"},"doc://com.github.kean.nuke/documentation/Nuke/ImageCache":{"url":"\/documentation\/nuke\/imagecache","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImageCache"}],"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageCache","abstract":[{"text":"An LRU memory cache.","type":"text"}],"title":"ImageCache","type":"topic","role":"symbol","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ImageCache"}]},"doc://com.github.kean.nuke/documentation/Nuke/ImagePrefetcher":{"title":"ImagePrefetcher","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ImagePrefetcher","kind":"identifier"}],"abstract":[{"text":"Prefetches and caches images to eliminate delays when requesting the same","type":"text"},{"text":" ","type":"text"},{"text":"images later.","type":"text"}],"kind":"symbol","role":"symbol","navigatorTitle":[{"text":"ImagePrefetcher","kind":"identifier"}],"type":"topic","url":"\/documentation\/nuke\/imageprefetcher","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImagePrefetcher"},"doc://com.github.kean.nuke/documentation/Nuke/caching":{"url":"\/documentation\/nuke\/caching","abstract":[{"type":"text","text":"Learn about cache layers in Nuke and how to configure them."}],"identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/caching","type":"topic","kind":"article","title":"Caching","role":"collectionGroup"},"https://en.wikipedia.org/wiki/Cache_algorithms#Examples":{"titleInlineContent":[{"text":"LRU (least recently used)","type":"text"}],"identifier":"https:\/\/en.wikipedia.org\/wiki\/Cache_algorithms#Examples","url":"https:\/\/en.wikipedia.org\/wiki\/Cache_algorithms#Examples","type":"link","title":"LRU (least recently used)"},"https://developer.apple.com/videos/play/wwdc2018/405/":{"titleInlineContent":[{"text":"WWDC 2018: Measuring Performance Using Logging","type":"text"}],"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/405\/","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/405\/","type":"link","title":"WWDC 2018: Measuring Performance Using Logging"},"doc://com.github.kean.nuke/documentation/Nuke":{"title":"Nuke","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke","kind":"symbol","url":"\/documentation\/nuke","type":"topic","role":"collection","abstract":[{"type":"text","text":"A powerful image loading system for Apple platforms."}]},"https://developer.apple.com/documentation/foundation/url_loading_system":{"titleInlineContent":[{"text":"Foundation URL Loading System","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/url_loading_system","url":"https:\/\/developer.apple.com\/documentation\/foundation\/url_loading_system","type":"link","title":"Foundation URL Loading System"},"https://developer.apple.com/documentation/foundation/operationqueue":{"titleInlineContent":[{"text":"operation queues","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/operationqueue","url":"https:\/\/developer.apple.com\/documentation\/foundation\/operationqueue","type":"link","title":"operation queues"},"https://developer.apple.com/documentation/foundation/urlcache":{"titleInlineContent":[{"code":"URLCache","type":"codeVoice"}],"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/urlcache","url":"https:\/\/developer.apple.com\/documentation\/foundation\/urlcache","type":"link","title":"URLCache"},"doc://com.github.kean.nuke/documentation/Nuke/ImageProcessors/Resize":{"navigatorTitle":[{"text":"Resize","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Resize","kind":"identifier"}],"url":"\/documentation\/nuke\/imageprocessors\/resize","abstract":[{"type":"text","text":"Scales an image to a specified size."}],"type":"topic","identifier":"doc:\/\/com.github.kean.nuke\/documentation\/Nuke\/ImageProcessors\/Resize","kind":"symbol","title":"ImageProcessors.Resize","role":"symbol"}}}